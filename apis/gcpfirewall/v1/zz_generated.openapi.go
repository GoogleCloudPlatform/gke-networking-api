//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

package v1

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewall":        schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewall(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallIngress": schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallIngress(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallSpec":    schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallSpec(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallStatus":  schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallStatus(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressDestination": schema_gke_networking_api_apis_gcpfirewall_v1_IngressDestination(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressSource":      schema_gke_networking_api_apis_gcpfirewall_v1_IngressSource(ref),
		"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.ProtocolPort":       schema_gke_networking_api_apis_gcpfirewall_v1_ProtocolPort(ref),
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewall(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GCPFirewall describes a GCP firewall spec that can be used to configure GCE firewalls. A GCPFirewallSpec will correspond 1:1 with a GCE firewall rule.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"description": {
						SchemaProps: spec.SchemaProps{
							Description: "Description describes a GCP firewall in a human-readable way. Usually it provides also information on the producer of this GCPFirewall custom resource.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Spec is the desired configuration for GCP firewall More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status is the runtime status of this GCP firewall More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallSpec", "github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallIngress(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GCPFirewallIngress describes a source and a destination for the ingress firewall rule.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"source": {
						SchemaProps: spec.SchemaProps{
							Description: "Source describes a peer to allow traffic from.",
							Ref:         ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressSource"),
						},
					},
					"destination": {
						SchemaProps: spec.SchemaProps{
							Description: "Destination specifies the target of the firewall rule. If this field is empty,\nthis rule allows traffic from specified sources to all kubernetes cluster entities.",
							Ref:         ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressDestination"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressDestination", "github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.IngressSource"},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GCPFirewallSpec provides the specification of a GCPFirewall. The firewall rule apply to the cluster associated targets (network tags or secure tags) which are deduced by the controller. As a result, the specified rule applies to ALL nodes and pods in the cluster.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"action": {
						SchemaProps: spec.SchemaProps{
							Description: "Rule action of the firewall rule. Only allow action is supported. If not specified, defaults to ALLOW.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"disabled": {
						SchemaProps: spec.SchemaProps{
							Description: "If set to true, the GCPFirewall is not synced by the controller.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of protocol/ ports which needs to be selected by this rule. If this field is empty or missing, this rule matches all protocol/ ports. If this field is present and contains at least one item, then this rule allows traffic only if the traffic matches at least one port in the list.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.ProtocolPort"),
									},
								},
							},
						},
					},
					"ingress": {
						SchemaProps: spec.SchemaProps{
							Description: "A collection of sources and destinations to determine which ingress traffic is allowed. If source is nil or empty, the traffic is allowed from all sources (0.0.0.0/0). If destination is nil or empty, the traffic is allowed to all kubernetes cluster entities (nodes, pods and services) from the specified sources. If both are nil, the traffic is allowed from all sources (0.0.00/0) to the cluster entities.",
							Ref:         ref("github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallIngress"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.GCPFirewallIngress", "github.com/GoogleCloudPlatform/gke-networking-api/apis/gcpfirewall/v1.ProtocolPort"},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_GCPFirewallStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GCPFirewallStatus is the runtime status of a GCP firewall",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type specifies the underlying GCE firewall implementation type. Takes one of the values from [VPC, REGIONAL, GLOBAL]",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceURL": {
						SchemaProps: spec.SchemaProps{
							Description: "Resource link for the GCE firewall rule. In case of FW 3.0, this is the GCE Network Firewall Policy resource.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority of the GCP firewall rule.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"type",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions describe the current condition of the firewall rule.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Condition"},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_IngressDestination(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressDestination specifies the target of the firewall rules. The destination entities specified are ANDed with GCE node network tags of the kubernetes cluster. In other words, the traffic is allowed to a destination IP address only if it belongs to one of the cluster nodes.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ipBlocks": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "IPBlocks specify the set of destination CIDRs that the rule applies to. If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the list. If this field is empty, this rule allows all destinations. Valid example list items are \"192.168.1.1/24\" or \"2001:db9::/64\".",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_IngressSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "IngressSource specifies the source of the firewall rules.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ipBlocks": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "IPBlocks specify the set of source CIDR ranges that the rule applies to. If this field is present and contains at least one item, this rule allows traffic only if the traffic matches at least one item in the list. If this field is empty, this rule allows all sources. Valid example list items are \"192.168.1.1/24\" or \"2001:db9::/64\".",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_gke_networking_api_apis_gcpfirewall_v1_ProtocolPort(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ProtocolPort describes the protocol and ports to allow traffic on.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"protocol": {
						SchemaProps: spec.SchemaProps{
							Description: "The protocol which the traffic must match.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"startPort": {
						SchemaProps: spec.SchemaProps{
							Description: "StartPort is the starting port of the port range that is selected on the firewall rule targets for the specified protocol. If EndPort is not specified, this is the only port selected. If StartPort is not provided, all ports are matched.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"endPort": {
						SchemaProps: spec.SchemaProps{
							Description: "EndPort is the last port of the port range that is selected on the firewall rule targets. If StartPort is not specified or greater than this value, then this field is ignored.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"protocol"},
			},
		},
	}
}
